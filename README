Logger(3)      User Contributed Perl Documentation      Logger(3)



NNNNAAAAMMMMEEEE
        Logger - Smart debugging tool which outputs logging messages in a nifty and elaborate format.


SSSSYYYYNNNNOOOOPPPPSSSSIIIISSSS
        Log messages to both STDERR and a file:


           use Logger::Logger;
           $debug_file = '/tmp/foo.log';
           $logger = new Logger::Logger ( $debug_file, 0 ) or die "Can't create object: Logger::Logger::Error;

           $logger->debug_message ( 'Logger will tell you the package, subroutine, line number and the time your debug message originated from' );
           $logger->separate;
           $logger->debug_message ( 'This line is separated from the previous one' );
           $logger->debug_message ( "Exception caught: $@", 'ERROR' ); # This message will blink in Red.
           $logger->debug_message ( "This line is much longer to fit in a single row. Logger will split it nicely, without chopping off words and display it in multiple rows" );


        Log messages quielty to a file ( daemon mode );


           use Logger::Logger;
           $debug_file = '/tmp/foo.log';
           $logger = new Logger::Logger ( $debug_file, 1 ) or die "Can't create object: Logger::Logger::Error;

           $logger->debug_message ( 'This message will be concatenated to your log file, without STDERR polution' );
           $logger->separate;


        Log messages to STERR only:
                  use Logger::Logger;
                  $logger = new Logger::Logger () or die "Can't create object: Logger::Logger::Error;

                  $logger->debug_message ( 'This message will appear on STDERR only' );
                  $logger->separate;


DDDDEEEESSSSCCCCRRRRIIIIPPPPTTTTIIIIOOOONNNN
           The Logger module is a nifty tool to organaize your debug messages, and thus your understand of the program flow.

           While writing your code you need a tool to output your debug messages.
           You want to see where the message originated from ( which module, which subroutine, line number and at what time ),
           so you can proceed directly to solving the matter, rather than search for it's location.

           You want to destinguish between an ERROR message, and yet another flow control message ( an INFO message ).
           Not only you want to see the messages on screen, you want to have them in a local file as well.
           Sometimes you might write a deamon that works in the background. In this case you need not see logging messages
           poluting your terminal.
           Logger does just that.

           There are 3 working modes for Logger:

           (1) Debugging to STDERR + file.
           (2) Debugging to STDERR only.
           (3) Debugging to file only ( daemon/silent mode ).


        _nn_ee_ww(((($$$$))))
               This constructor expects two parameters:
               (1) A file name to output all message to.
               (2) Daemon mode boolian flag ( 1 for true, 0 for false ).

               If the first argument is omitted, logging will occur to STDERR only.
               If the second argument is ommited, deamon mode defaults to false.

               Upon success, a blessed hash reference will be returned.
               Upon failure the method returns 0 and the global $Error varabile will hold the error message
               ( Accessing it - $Logger::Logger::Error ).


        ddddeeeebbbbuuuugggg____mmmmeeeessssssssaaaaggggeeee(((($$$$$$$$))))
               This method takes two argument - the debug message you wish to log, and the type of the message.
               Currently supported type is 'ERROR'. When the second argument is 'ERROR', the debug message willl appear
               in Red color ( in case your Terminal supports it ), thus distinguishing it from other 'INFO' messages.

               Upon success - the method returns 1.
               Upon failre  - the method returns 0.

               The Logger object does all the work behind the scenes:
               (1) Grab the time, package, subroutine name and line number which the message originated from.
               (2) Create a nice format with the parameters aforementioned.
               (3) Output it according to object type.


        _ss_ee_pp_aa_rr_aa_tt_ee_((_))
               You may wish to create visual separation between messages.
               When you invoke separate(), a line consistant of '-' will be outputed.

               This length is automatically calculated by Logger.


CCCCOOOONNNNFFFFIIIIGGGGUUUURRRRAAAATTTTIIIIOOOONNNN ---- WWWWIIIIDDDDTTTTHHHH CCCCOOOONNNNTTTTRRRROOOOLLLL
           The Logger module uses pack() to indent the output.
           You can control the  width of each field by altering the code:

           my $time_pack = 'A18'; This mean the 'TIME' column is 18 byte long.
           my $sub_pack  = 'A39';
           my $line_pack = 'A6';
           my $msg_pack  = 'A97';

           Upon modification of this fields, Logger automatically calculates the new scheme,
           and adjusts all relevant fields accordingly, to your convenience.


BBBBUUUUGGGGSSSS
           None at the moment.
           If you have any question or comment - pengas@cpan.org


CCCCOOOOPPPPYYYYRRRRIIIIGGGGHHHHTTTT
           Copyright 2001-2002, Pengas Nir

           This library is free software - you can redistribute
           it and/or modify it and/or do what ever you damn desire -
           under the same terms as Perl itself.




2002-08-15                 perl v5.6.1                  Logger(3)
